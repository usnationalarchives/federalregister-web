#=require app

class @FR2.CommentFormFileUploader
  @ATTACHED_COMMENT_MESSAGE: 'See attached file(s)'

  constructor: (commentFormHandler)->
    @fileUploadSubmissionKey = null
    @commentFormHandler = commentFormHandler
    @submissionKeyUrl = "#{@commentFormHandler.regulationsDotGovBaseUrl()}/submission-keys"
    @fileUploadUrlsUrl = "#{@commentFormHandler.regulationsDotGovBaseUrl()}/file-upload-urls"
    @uploadedFiles = []

  initialize: ->
    @attachUploader()
    @addCompleteEvents()
    @addUploadEvents()
    @addDestroyEvents()
    @displayExistingAttachments()
    @displayAttachmentErrors()
    @commentForm().uploaderReady true

  commentForm: ->
    @commentFormHandler.commentForm

  commentFormEl: ->
    @commentForm().commentFormEl()

  commentField: ->
    @commentFormEl()
      .find '#comment_comment'

  attachmentContainer: ->
    @commentFormEl()
      .find '.attachments tbody'

  existingAttachments: ->
    @commentFormEl()
      .find '.attachments'
      .data 'existing'

  attachedCommentMessage: ->
    @constructor.ATTACHED_COMMENT_MESSAGE

  attachUploader: ->
    @uploaderEl = $( @commentFormEl().find('#fileupload') )
    uploader = @

    @uploader = @uploaderEl.fileupload(
      {
        url: ''
        dataType: 'json',
        processQueue: [
          {
            action: 'validate',
            always: true,
            acceptFileTypes: /(\.|\/)(<%= CommentAttachment::ALLOWED_EXTENSIONS.join('|')%>)$/i
            maxFileSize: <%= CommentAttachment::MAX_FILE_SIZE %>
            maxNumberOfFiles: <%= Comment::MAX_ATTACHMENTS %>
          }
        ],
        autoUpload: true,
        sequentialUploads: true,
        dataType: 'xml',
        singleFileUploads: false,
        excludeCsrfTokenHeader: true,
        add: (e, data) ->
          if (e.isDefaultPrevented())
            false

          t = $(@)
          that = t.data('blueimp-fileupload') || t.data('fileupload')
          options = that.options

          data.context = that._renderUpload(data.files)
            .data('data', data)
            .addClass('processing')

          val = if options.prependFiles then 'prepend' else 'append'
          options.filesContainer[val](data.context)

          that._forceReflow(data.context)
          that._transition(data.context)

          data.process ->
            t.fileupload('process', data)
            .always ->
              data.context.each (index) ->
                $(@).find('.size').text(
                  that._formatFileSize(data.files[index].size)
                )
              .removeClass('processing')
              that._renderPreviews(data)
            .done ->
              uploader.fetchFileUploadSubmissionKey().then (fileUploadSubmissionKey) ->
                _.each data.files, (file) ->
                  uploader.requestFileUploadUrl(file, fileUploadSubmissionKey).then (fileUploadUrl) ->
                    data.type = "PUT"
                    data.data = file
                    data.crossDomain = true
                    data.contentType = file.type
                    data.processData = false
                    data.url = fileUploadUrl

                    uploaderEl = uploader.uploaderEl
                    that = uploaderEl.data('blueimp-fileupload')

                    data.submit()
                      .success ->
                        uploader.uploadedFiles.push(file)
              .fail ->
                # TODO:
        # formData: {},
        filesContainer: @attachmentContainer()
        getFilesFromResponse: (res, files) ->
          _.map res.files, (file) ->
            {
              name: file.name,
              size: file.size,
              # url: res.url,
              url: null,
              # thumbnailUrl: res.url,
              # TODO: handle deletes
              # deleteUrl: "handle deletes",
              # deleteType: "DELETE",
            }
        uploadTemplateId: null
        downloadTemplateId: null
        uploadTemplate: (o)->
          source = $("#comment-attachment-upload-template").html()
          template = Handlebars.compile source
          template o
        downloadTemplate: (o)->
          source = $("#comment-attachment-complete-template").html()
          template = Handlebars.compile source
          template o
        destroy: (e, data) ->
          if e.isDefaultPrevented()
            return false

          t = $(@).data('blueimp-fileupload') ||$(this).data('fileupload')
          t._transition(data.context).done ->
            $(@).remove()
            t._trigger('destroyed', e, data)
      }
    )
    .data('blueimpFileupload')

  fetchFileUploadSubmissionKey: ->
    context = this
    deferred = $.Deferred()

    unless @fileUploadSubmissionKey
      $.ajax(
        url: @submissionKeyUrl,
        type: "POST",
        contentType: "application/vnd.api+json",
        crossDomain: true,
        data: JSON.stringify({ data: { type: "submission-keys" }}),
        dataType: 'json',
        excludeCsrfTokenHeader: true,
        beforeSend: (xhr, settings) ->
          xhr.setRequestHeader(
            'x-api-key',
            context.commentFormHandler.apiKey()
          )
        success: (res, status) =>
          @fileUploadSubmissionKey = res.data.id
          deferred.resolve(@fileUploadSubmissionKey)
        error: () ->
          deferred.reject()
        complete: ->
      )
    else
      deferred.resolve(@fileUploadSubmissionKey)

    return deferred.promise()

  requestFileUploadUrl: (file, fileUploadSubmissionKey) ->
    context = this
    deferred = $.Deferred()

    $.ajax(
      url: @fileUploadUrlsUrl,
      type: "POST",
      contentType: "application/vnd.api+json",
      crossDomain: true,
      excludeCsrfTokenHeader: true,
      data: JSON.stringify({
        data: {
          type: "file-upload-urls",
          attributes: {
            fileName: file.name,
            submissionKey: fileUploadSubmissionKey,
            contentType: file.type
          }
        }
      }),
      dataType: 'json',
      beforeSend: (xhr, settings) ->
        xhr.setRequestHeader(
          'x-api-key',
          context.commentFormHandler.apiKey()
        )
      success: (res, status) =>
        deferred.resolve(res.data.id)
      error: () ->
        deferred.reject()
      complete: ->
    )
    return deferred.promise()

  attachmentEl: ->
    $('.attachments tbody')

  filesUploading: ->
    @attachmentEl()
      .find '.template-upload'
      .not '.error'
      .length > 0

  filesWithErrors: ->
    @attachmentEl()
      .find '.template-upload.error'
      .length > 0

  uploaderInProgress: ->
    @filesUploading()

  uploaderHasErrors: ->
    @filesWithErrors()

  uploaderReady: ->
    ! @uploaderInProgress() && ! @uploaderHasErrors()

  updateUploaderStatus: (event)->
    if event == 'submit' || event == 'fail'
      @commentForm().uploaderReady false
    else if (event == 'complete' || event == 'destroy') && @uploaderReady()
      @commentForm().uploaderReady true

  addUploadEvents: ->
    @uploaderEl
      .bind 'fileuploadsubmit', (e, data)=>
        @updateUploaderStatus 'submit'
        true

    @uploaderEl
      .bind 'fileuploadprocessfail', (e, data)=>
        @updateUploaderStatus 'fail'
        if data.files.error
          _.each data.context, (el, index)=>
            error = data.files[index].error
            $el = $(el)
            if error
              $el
                .closest 'tr'
                .addClass 'error'
              $el
                .find '.progress-bar'
                .html error
              $el
                .find '.button.cancel .action'
                .text 'Delete'

    # this is triggered when a file with an error is removed
    # from the file list - go figure...
    @uploaderEl
      .bind 'fileuploadfail', (e,data)=>
        @updateUploaderStatus 'destroy'

  addCompleteEvents: ->
    @uploaderEl.bind 'fileuploadcompleted', (e, data)=>
      if @commentField().val() == ''
        @commentField().val( @attachedCommentMessage() )

      @commentForm().storeComment()
      @updateUploaderStatus 'complete'

  addDestroyEvents: ->
    @uploaderEl.bind 'fileuploaddestroyed', (e, data) =>

      # TODO: extract and update draft
      removedFileName = data.context.data('name')
      @uploadedFiles = _.without @uploadedFiles, _.findWhere(@uploadedFiles, { name: removedFileName })

      @clearCommentPlaceholder()
      @updateUploaderStatus 'destroy'

  clearCommentPlaceholder: ->
    if @commentField().val() == @attachedCommentMessage() && @attachmentContainer().children('tr:not(.error)').length == 0
      @commentField().val ''

  displayExistingAttachments: ->
    @uploader
      ._renderDownload @existingAttachments()
      .appendTo @attachmentContainer()

    @clearCommentPlaceholder()

  displayAttachmentErrors: ->
    priorValidations = @uploader._hasError
    fileUploader = this

    @uploader._hasError = (file)->
      _.each fileUploader.attachmentContainer().find('tr'), (i, el)->
        $el = $(el)
        if $el.data('name') == file.name
          file.error = 'A file with the same name has already been attached.'

      priorValidations.call(this, file)

  reset: ->
    @attachmentContainer().empty()
    @uploadedFiles = []
    @fileUploadSubmissionKey = null
